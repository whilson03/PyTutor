<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title> Basic syntax </title>
    <style>
	h1{
	    color: black;
		font-family: Armenia;
	}

    </style>
</head>


<body>
<h1> BASIC SYNTAX </h1>
<div id="introduction">
    </br>
    <h2> First Python Program </h2>
    </br>
    <h3>Interactive Mode Programming</h3>
    </br>
    Invoking the interpreter without passing a script file as a parameter brings up the following
    prompt-
    <p>$ python </p>
    <p>Python 3.3.2 (default, Dec 10 2013, 11:35:01)</p>
    <p>[GCC 4.6.3] on Linux</p>
    <p>Type "help", "copyright", "credits", or "license" for more information.</p>
    >>>
    <p>On Windows:</p>
    <p>Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:43:06) [MSC v.1600 32 bit (Intel)] on</p>
    <p>win32</p>
    <p>Type "copyright", "credits" or "license()" for more information.</p>
    >>></br>
    <p><strong>Type the following text at the Python prompt and press Enter-</strong></p>
    >>> print ("Hello, Python!")</br></br>


    <h2>Script Mode Programming</h2>
    <p>We assume that you have the Python interpreter set in PATH variable. Now, try to run
        this program as follows- </p>
</div>
<div id="habitat">
    <h3>On Linux </h3>
    <strong>$ python test.py</strong>...
    This produces the following result :-
    <strong>Hello, Python!</strong>
    <h3>On Windows</h3>
    <strong>C:\Python34>Python test.py...</strong>
    This produces the following result :-
    <strong>Hello, Python!</strong></br></br>
    Let us try another way to execute a Python script in Linux. Here is the modified test.py
    file-</br></br>

    <strong>#!/usr/bin/python3</br>
        print ("Hello, Python!")</br></strong></br>

    We assume that you have Python interpreter available in the /usr/bin directory. Now, try
    to run this program as follows-</br>
    <strong>$ chmod +x test.py # This is to make file executable</br>
        $./test.py</strong>
    ....This produces the following result-
    <strong>Hello, Python!</strong>

    <h2>Python Identifiers</h2>
    <p>A Python identifier is a name used to identify a variable, function, class, module or other
        object. An identifier starts with a letter A to Z or a to z or an underscore (_) followed by
        zero or more letters, underscores and digits (0 to 9).
        Python does not allow punctuation characters such as @, $, and % within identifiers.
        Python is a case sensitive programming language. Thus, Manpower and manpowerare
        two different identifiers in Python.</br>
        Here are naming conventions for Python identifiers-</p>

    <ul>
        <li> Class names start with an uppercase letter. All other identifiers start with a
            lowercase letter.
        </li>
        <li> Starting an identifier with a single leading underscore indicates that the identifier
            is private.
        </li>
        <li> Starting an identifier with two leading underscores indicates a strong private
            identifier.
        </li>
        <li> If the identifier also ends with two trailing underscores, the identifier is a
            languagedefined
            special name.
        </li>

    </ul>
    <h3>Reserved Words</h3>
    <p>The following list shows the Python keywords.All the Python keywords
        contain lowercase letters only.</br>
        (<em>and, exec, Not,
            as, finally, or,
            assert, for, pass,
            break, from, print,
            class, global, raise,
            continue, if, return,
            def, import, try
            del, in, while,
            elif,, is, with
            else, lambda, yield,
            except.</em>)</br>
        Lines and Indentation
        Python does not use braces({}) to indicate blocks of code for class and function definitions
        or flow control. Blocks of code are denoted by line indentation, which is rigidly enforced.
        The number of spaces in the indentation is variable, but all statements within the block
        must be indented the same amount. For example:-</p></br>
    <strong>if True:</br>
        &nbsp;&nbsp;print ("True")</br>
        else:</br>
        &nbsp;&nbsp;print ("False")</strong></br>
    <p>However, the following block generates an error-</p>
    <strong>if True:</br>
        print ("Answer")</br>
        print ("True")</br>
        else:</br>
        print "(Answer")</br>
        print ("False")</strong></br>
    *Don't forget your indentation*</p></br>
    Note: Do not try to understand the logic at this point of time. Just make sure you
    understood the various blocks even if they are without braces

    <p><strong>#!/usr/bin/python3</br>
        import sys</br>
        try:</br>
        &nbsp;&nbsp;&nbsp;# open file stream</br>
        &nbsp;&nbsp;&nbsp;file = open(file_name, "w")</br>
        except IOError:</br>
        &nbsp;&nbsp;&nbsp;print ("There was an error writing to", file_name)</br>
        &nbsp;&nbsp;&nbsp;sys.exit()</br>
        print ("Enter '", file_finish,)</br>
        print "' When finished"</br>
        while file_text != file_finish:</br>
        &nbsp;&nbsp;file_text = raw_input("Enter text: ")</br>
        &nbsp;&nbsp;if file_text == file_finish:</br>
        &nbsp;&nbsp;&nbsp;&nbsp;# close the file</br>
        &nbsp;&nbsp;&nbsp;&nbsp;file.close</br>
        &nbsp;&nbsp;&nbsp;&nbsp;break</br>
        &nbsp;&nbsp;file.write(file_text)</br>
        &nbsp;&nbsp;file.write("\n")</br>
        file.close()</br>
        file_name = input("Enter filename: ")</br>
        if len(file_name) == 0:</br>
        &nbsp;&nbsp;&nbsp;&nbsp;print ("Next time please enter something")</br>
        &nbsp;&nbsp;&nbsp;&nbsp;sys.exit()</br>
        try:</br>
        &nbsp;&nbsp;&nbsp;&nbsp;file = open(file_name, "r")</br>
        except IOError:</br>
        &nbsp;&nbsp;&nbsp;&nbsp;print ("There was an error reading file")</br>
        &nbsp;&nbsp;&nbsp;&nbsp;sys.exit()</br>
        file_text = file.read()</br>
        file.close()</br>
        print (file_text)</br></p>
    </strong>

</div>
<div id="media">
    <h2>Multi-Line Statements</h2>
    Statements in Python typically end with a new line. Python, however, allows the use of
    the line continuation character (\) to denote that the line should continue. For
    example</br></br>
    <strong>total=&nbsp;&nbsp;item_one + \</br>
        &nbsp;&nbsp;&nbsp;&nbsp;item_two + \</br>
        &nbsp;&nbsp;&nbsp;&nbsp;item_three</strong></br></br>
    The statements contained within the [], {}, or () brackets do not need to use the line
    continuation character. For example</br></br>
    days = <strong> ['Monday', 'Tuesday', 'Wednesday','Thursday', 'Friday']</strong>
    <h2>Quotation in Python</h2>
    <p>Python accepts single ('), double (") and triple (''' or """) quotes to denote string
        literals,
        as long as the same type of quote starts and ends the string.
        The triple quotes are used to span the string across multiple lines. For example, all the
        following are legal</br></br>
        <strong>word = 'word'</br></br>
            sentence = "This is a sentence."</br></br>
            paragraph = """This is a paragraph. It is</br></br>
            made up of multiple lines and sentences."""</strong></br></br>
    </p>

    <h2>Comments in Python</h2>
    A hash sign (#) that is not inside a string literal is the beginning of a comment. All
    characters after the #, up to the end of the physical line, are part of the comment and the
    Python interpreter ignores them.
    A hash sign (#) that is not inside a string literal is the beginning of a comment. All
    characters after the #, up to the end of the physical line, are part of the comment and the
    Python interpreter ignores them.</br></br>
    <strong>#!/usr/bin/python3</br></br>
        18</br></br>
        # First comment</br></br>
        print ("Hello, Python!") # second comment</strong></br></br>
    This produces the following result :-
    <strong>Hello, Python!</strong>

    <h2>Using Blank Lines</h2>
    A line containing only whitespace, possibly with a comment, is known as a blank line and
    Python totally ignores it.
    In an interactive interpreter session, you must enter an empty physical line to terminate
    a multiline statement.

    <h2>Waiting for the User</h2>
    The following line of the program displays the prompt and the statement saying “Press the
    enter key to exit”, and then waits for the user to take action −</br></br>
    <strong>#!/usr/bin/python3</br>
        input("\n\nPress the enter key to exit.")</strong></br></br>
    Here, "\n\n" is used to create two new lines before displaying the actual line. Once the
    user presses the key, the program ends. This is a nice trick to keep a console window open
    until the user is done with an application.

    <h2>Command Line Arguments</h2>
    Many programs can be run to provide you with some basic information about how they
    should be run. Python enables you to do this with -h:</br></br>
    <strong>$ python -h</br>
        usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...</br>
        Options and arguments (and corresponding environment variables):</br>
        -c cmd : program passed in as string (terminates option list)</br>
        -d : debug output from parser (also PYTHONDEBUG=x)</br>
        -E : ignore environment variables (such as PYTHONPATH)</br>
        -h : print this help message and exit</br>
        [ etc. ]</strong></br></br>
    You can also program your script in such a way that it should accept various
    options. Command Line Arguments is an advance topic. Let us understand it.
    <h2>Command Line Arguments</h2>
    Python provides a getopt module that helps you parse command-line options and
    arguments.</br></br>
    <strong>$ python test.py arg1 arg2 arg3</strong></br></br>
    The Python sys module provides access to any command-line arguments via
    the sys.argv. This serves two purposes-</br>
    <ul>
        <li> sys.argv is the list of command-line arguments.</li>
        <li> len(sys.argv) is the number of command-line arguments.</li>
    </ul>
    Here sys.argv[0] is the program i.e. the script name.

    <h2>Parsing Command-Line Arguments</h2>
    Python provided a getopt module that helps you parse command-line options and
    arguments. This module provides two functions and an exception to enable command line
    argument parsing.
    <h3>getopt.getopt method</h3>
    This method parses the command line options and parameter list. Following is a simple
    syntax for this methodgetopt.</br></br>
    <strong>getopt(args, options, [long_options])</strong></br></br>
    Here is the detail of the parameters-</br>

    <ul>
        <li> args: This is the argument list to be parsed.</li>
        <li> options: This is the string of option letters that the script wants to recognize, with
            options that require an argument should be followed by a colon (:).
        </li>
        <li> long_options: This is an optional parameter and if specified, must be a list of
            strings with the names of the long options, which should be supported. Long
            options, which require an argument should be followed by an equal sign ('='). To
            accept only long options, options should be an empty string.
        </li>
        <li> This method returns a value consisting of two elements- the first is a list
            of (option, value) pairs, the second is a list of program arguments left after the
            option list was stripped
        </li>
        <li> Each option-and-value pair returned has the option as its first element, prefixed
            with a hyphen for short options (e.g., '-x') or two hyphens for long options (e.g., '-
            -long-option').
        </li>
        <h3>Exception getopt.GetoptError</h3>
        This is raised when an unrecognized option is found in the argument list or when an option
        requiring an argument is given none.
        The argument to the exception is a string indicating the cause of the error. The
        attributes msg and opt give the error message and related option.
    </ul>

    <h3>Example</h3>
    Suppose we want to pass two file names through command line and we also want to give
    an option to check the usage of the script. Usage of the script is as follows</br></br>
    <strong>usage: test.py -i (inputfile) -o (outputfile) </strong></br>
    Here is the following script to test.py-
    <strong>#!/usr/bin/python3</br>
        import sys, getopt</br>
        def main(argv):</br>
        &nbsp;&nbsp;&nbsp;inputfile = ''</br>
        &nbsp;&nbsp;&nbsp;outputfile = ''</br>
        &nbsp;&nbsp;&nbsp;try:</br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opts, args =
        getopt.getopt(argv,"hi:o:",["ifile=","ofile="])</br>
        except getopt.GetoptError:</br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print ('test.py -i
        <inputfile> -o
            <outputfile>')</br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit(2)</br>
                for opt, arg in opts:</br>
                &nbsp;&nbsp;&nbsp;if opt == '-h':</br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print ('test.py -i
                <inputfile> -o
                    <outputfile>')</br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()</br>
                        &nbsp;&nbsp;&nbsp;elif opt in ("-i", "--ifile"):</br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputfile = arg</br>
                        &nbsp;&nbsp;&nbsp;elif opt in ("-o", "--ofile"):</br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputfile = arg</br>
                        &nbsp;&nbsp;&nbsp;print ('Input file is "', inputfile)</br>
                        &nbsp;&nbsp;&nbsp;print ('Output file is "', outputfile)</br>
                        if __name__ == "__main__":</br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main(sys.argv[1:])
    </strong></br></br>

    Now, run the above script as follows-</br></br>
    <strong>$ test.py -h</br>
        usage: test.py -i
        <inputfile> -o
            <outputfile></br>
                $ test.py -i BMP -o</br>
                usage: test.py -i
                <inputfile> -o
                    <outputfile></br>
                        $ test.py -i inputfile -o outputfile</br>
                        Input file is " inputfile</br>
                        Output file is " outputfile
    </strong>
</div>


</body>
	